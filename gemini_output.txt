---
### **Sub-Agent Instructions: Final Verification**

*(Orchestrator: You will provide these instructions to the final verification sub-agent in Phase 3.B.)*

**Your Goal:** Perform a final, holistic review of all newly created docstrings to ensure they are consistent, accurate, and architecturally sound.

**Your Context:**
*   **All Modules:** The full content of every module in `ptycho/` is available in the `repomix` context.
*   **Dependency Report:** `ptycho/dependency_report.txt`

**Your Workflow:**

1.  **Holistic Review:** Read through every single module docstring in the `ptycho/` directory.
2.  **Identify Inconsistencies:** Look for contradictions between docstrings. For example, does `loader.py`'s docstring accurately describe its relationship with `raw_data.py` as documented in `raw_data.py`?
3.  **Verify Architectural Soundness:** Use the `dependency_report.txt` to cross-reference the documented dependencies. Ensure that the "Architecture Role" and "Dependencies" sections in each docstring are correct.
4.  **Correct Errors:** If you find any errors or inconsistencies, fix them directly in the respective files.
5.  **Report Completion:** Once you have verified all docstrings and made any necessary corrections, report back that the final verification is complete.
</file>

<file path=".claude/commands/refactor/refactor-code.md">
You are an expert programmer.
The user wants you to refactor the code in the file specified in the context.
Please refactor the code to address the user's request.
The user's request is:
{{.Args}}

The file that needs to be refactored is:
{{.Code}}

Please think step by step and then write the refactored code.
Do not output the file path, just the refactored code.
</file>

<file path=".claude/commands/analyze-gemini.md">
# Command: /analyze-gemini

**Goal:** Analyze a codebase to identify potential issues, suggest improvements, and answer specific questions based on the user's request.

**Usage:**
`/analyze-gemini "Is the current implementation of the data loader efficient?"`
`/analyze-gemini "Review the `ptycho/model.py` file for potential bugs and suggest refactorings."`

---

## üî¥ **CRITICAL: MANDATORY EXECUTION FLOW**

**YOUR ROLE IS AN AUTONOMOUS ORCHESTRATOR AND FILE MANAGER. YOU DO NOT PERFORM THE ANALYSIS.**
1.  You MUST gather the user's high-level objective from the command arguments.
2.  You MUST run `repomix` to create a complete, fresh snapshot of the codebase context.
3.  You MUST build a structured prompt file (`analysis-prompt.md`) to delegate the analysis to Gemini.
4.  You MUST execute `gemini -p "@analysis-prompt.md"`.
5.  You MUST output Gemini's response directly to the user.

**DO NOT:**
-   ‚ùå Run `find`, `grep`, or any other manual analysis tool. Gemini is responsible for all analysis.
-   ‚ùå Create the analysis yourself. Your job is to run the process and manage the state.

---

## ü§ñ **YOUR EXECUTION WORKFLOW**

| ID | Task Description | State | How/Why & API Guidance |
| :-- | :--- | :--- | :--- |
| 1.A | **Aggregate Codebase Context** | `[ ]` | **Why:** To provide Gemini with a complete and fresh snapshot of the project for accurate analysis. <br> **How:** Execute the following command now. <br> ```bash <br> # The user's high-level objective is in $ARGUMENTS <br> npx repomix@latest . \ <br>   --include "ptycho/**/*.py,**/*.md" \ <br>   --ignore "build/**,node_modules/**,dist/**,*.lock,scripts/**,**/*.ipynb" <br> <br> if [ ! -s ./repomix-output.xml ]; then <br>     echo "‚ùå ERROR: Repomix failed to generate the codebase context. Aborting." <br>     exit 1 <br> fi <br> echo "‚úÖ Codebase context aggregated into repomix-output.xml." <br> ``` |
| 1.B | **Build Gemini Prompt** | `[ ]` | **Why:** To create a structured, verifiable prompt that delegates the entire analysis task to Gemini. <br> **How:** Execute the following commands now to create `analysis-prompt.md`. <br> ```bash <br> # Create the structured prompt for Gemini <br> cat > ./analysis-prompt.md << 'PROMPT' <br> <task> <br> You are an expert Staff Engineer. Your task is to analyze the provided codebase to answer the user's question or perform the requested analysis. <br> <br> <steps> <br> <1> <br> Carefully read the `<user_request>` to understand the user's goal. <br> </1> <br> <2> <br> Thoroughly analyze the entire `<codebase_context>` to gather all relevant information. <br> </2> <br> <3> <br> Synthesize your findings into a clear, concise, and well-structured response that directly addresses the user's request. <br> </3> <br> <4> <br> If the user asks for suggestions or identifies a problem, provide actionable recommendations and code examples where appropriate. <br> </4> <br> </steps> <br> <br> <context> <br> <user_request> <br> [Placeholder for the user's request] <br> </user_request> <br> <br> <codebase_context> <br> <!-- Placeholder for content from repomix-output.xml --> <br> </codebase_context> <br> </context> <br> <br> <output_format> <br> Your response should be in clear, human-readable Markdown. Use code blocks, bullet points, and other formatting to improve clarity. Do not use any special tags or structured output formats unless the user explicitly asks for it. <br> </output_format> <br> </task> <br> PROMPT <br> <br> # Inject the user request and repomix context into the prompt <br> echo "$ARGUMENTS" > ./tmp/user_request.tmp <br> sed -i '/<user_request>/r ./tmp/user_request.tmp' ./analysis-prompt.md <br> sed -i '/<codebase_context>/r ./repomix-output.xml' ./analysis-prompt.md <br> rm ./tmp/user_request.tmp <br> <br> echo "‚úÖ Gemini analysis prompt created at analysis-prompt.md" <br> ``` |
| 1.C | **Execute Gemini Analysis** | `[ ]` | **Why:** To run the analysis and generate the response. <br> **How:** Execute the `gemini` command now. <br> ```bash <br> # Execute Gemini with the fully-formed prompt file <br> gemini -p "@./analysis-prompt.md" <br> ``` |
</file>

<file path=".claude/commands/checklist-gemini.md">
# Command: /checklist-gemini

**Goal:** Generate a detailed, step-by-step checklist for completing a complex software engineering task.

**Usage:**
`/checklist-gemini "Refactor the authentication system to use JWT instead of session cookies."`

---

## üî¥ **CRITICAL: MANDATORY EXECUTION FLOW**

**YOUR ROLE IS AN AUTONOMOUS ORCHESTRATOR AND FILE MANAGER. YOU DO NOT PERFORM THE ANALYSIS.**
1.  You MUST gather the user's high-level objective from the command arguments.
2.  You MUST run `repomix` to create a complete, fresh snapshot of the codebase context.
3.  You MUST build a structured prompt file (`checklist-prompt.md`) to delegate the planning to Gemini.
4.  You MUST execute `gemini -p "@checklist-prompt.md"`.
5.  You MUST output Gemini's response directly to the user as a Markdown checklist.

**DO NOT:**
-   ‚ùå Run `find`, `grep`, or any other manual analysis tool. Gemini is responsible for all planning.
-   ‚ùå Create the checklist yourself. Your job is to run the process and manage the state.

---

## ü§ñ **YOUR EXECUTION WORKFLOW**

| ID | Task Description | State | How/Why & API Guidance |
| :-- | :--- | :--- | :--- |
| 1.A | **Aggregate Codebase Context** | `[ ]` | **Why:** To provide Gemini with a complete and fresh snapshot of the project for accurate planning. <br> **How:** Execute the following command now. <br> ```bash <br> # The user's high-level objective is in $ARGUMENTS <br> npx repomix@latest . \ <br>   --include "ptycho/**/*.py,**/*.md" \ <br>   --ignore "build/**,node_modules/**,dist/**,*.lock,scripts/**,**/*.ipynb" <br> <br> if [ ! -s ./repomix-output.xml ]; then <br>     echo "‚ùå ERROR: Repomix failed to generate the codebase context. Aborting." <br>     exit 1 <br> fi <br> echo "‚úÖ Codebase context aggregated into repomix-output.xml." <br> ``` |
| 1.B | **Build Gemini Prompt** | `[ ]` | **Why:** To create a structured, verifiable prompt that delegates the entire planning task to Gemini. <br> **How:** Execute the following commands now to create `checklist-prompt.md`. <br> ```bash <br> # Create the structured prompt for Gemini <br> cat > ./checklist-prompt.md << 'PROMPT' <br> <task> <br> You are an expert Staff Engineer. Your task is to create a detailed, step-by-step checklist for completing a complex software engineering task, based on the user's request and the provided codebase. <br> <br> <steps> <br> <1> <br> Analyze the `<user_request>` to understand the high-level goal. <br> </1> <br> <2> <br> Thoroughly analyze the `<codebase_context>` to identify all affected files, modules, and potential side effects. <br> </2> <br> <3> <br> Break down the task into small, logical, and sequential steps. Each step should represent a single, verifiable action. <br> </3> <br> <4> <br> For each step, provide a clear description, the file(s) to be modified, and if applicable, a high-level summary of the code changes required. <br> </4> <br> <5> <br> Organize the steps into logical phases (e.g., "Phase 1: Setup & Configuration", "Phase 2: Core Logic Implementation", "Phase 3: Testing & Verification"). <br> </5> <br> <6> <br> Generate the final output as a Markdown checklist, strictly adhering to the format specified in `<output_format>`. <br> </6> <br> </steps> <br> <br> <context> <br> <user_request> <br> [Placeholder for the user's request] <br> </user_request> <br> <br> <codebase_context> <br> <!-- Placeholder for content from repomix-output.xml --> <br> </codebase_context> <br> </context> <br> <br> <output_format> <br> Your entire response must be a single Markdown checklist. Do not include any conversational text or other explanations. <br> <br> # Project: [Project Name from User Request] <br> <br> ## Phase 1: [Phase Name] <br> <br> - [ ] **Step 1.1:** [Description of step] <br>   - **File(s):** `path/to/file1.py`, `path/to/file2.js` <br>   - **Notes:** [Brief explanation of what needs to be done] <br> - [ ] **Step 1.2:** [Description of step] <br>   - **File(s):** `path/to/file3.css` <br>   - **Notes:** [Brief explanation] <br> <br> ## Phase 2: [Phase Name] <br> <br> - [ ] **Step 2.1:** [Description of step] <br>   - **File(s):** `path/to/file4.py` <br>   - **Notes:** [Brief explanation] <br> <br> ...and so on. <br> </output_format> <br> </task> <br> PROMPT <br> <br> # Inject the user request and repomix context into the prompt <br> echo "$ARGUMENTS" > ./tmp/user_request.tmp <br> sed -i '/<user_request>/r ./tmp/user_request.tmp' ./checklist-prompt.md <br> sed -i '/<codebase_context>/r ./repomix-output.xml' ./checklist-prompt.md <br> rm ./tmp/user_request.tmp <br> <br> echo "‚úÖ Gemini checklist prompt created at checklist-prompt.md" <br> ``` |
| 1.C | **Execute Gemini Analysis** | `[ ]` | **Why:** To run the analysis and generate the checklist. <br> **How:** Execute the `gemini` command now. <br> ```bash <br> # Execute Gemini with the fully-formed prompt file <br> gemini -p "@./checklist-prompt.md" <br> ``` |
</file>

<file path=".claude/commands/complete-phase-gemini-full.md">
# Command: /complete-phase-gemini-full

**Goal:** Autonomously complete a specific phase of a software engineering project by implementing the required code changes as defined in a checklist.

**Usage:**
`/complete-phase-gemini-full "Phase 2: Core Logic Implementation"`

---

## üî¥ **CRITICAL: MANDATORY EXECUTION FLOW**

**YOUR ROLE IS AN AUTONOMOUS ORCHESTRATOR AND FILE MANAGER. YOU DO NOT PERFORM THE IMPLEMENTATION.**
1.  You MUST identify the target phase from the command arguments.
2.  You MUST read the project's `checklist.md` to find the specific steps for that phase.
3.  You MUST run `repomix` to create a complete, fresh snapshot of the codebase context.
4.  You MUST build a structured prompt file (`implementation-prompt.md`) to delegate the implementation to Gemini.
5.  You MUST execute `gemini -p "@implementation-prompt.md"`.
6.  You MUST parse Gemini's response, which will contain the modified file contents.
7.  You MUST apply the changes to the actual files on the filesystem.

**DO NOT:**
-   ‚ùå Write or modify any code yourself. Gemini is responsible for all implementation.
-   ‚ùå Guess which files to modify. The checklist and Gemini's response are the sources of truth.
-   ‚ùå Proceed if Gemini's response is invalid or does not follow the specified format.

---

## ü§ñ **YOUR EXECUTION WORKFLOW**

| ID | Task Description | State | How/Why & API Guidance |
| :-- | :--- | :--- | :--- |
| 1.A | **Aggregate Codebase Context** | `[ ]` | **Why:** To provide Gemini with a complete and fresh snapshot of the project for accurate implementation. <br> **How:** Execute the following command now. <br> ```bash <br> # The user's high-level objective is in $ARGUMENTS <br> npx repomix@latest . \ <br>   --include "ptycho/**/*.py,**/*.md" \ <br>   --ignore "build/**,node_modules/**,dist/**,*.lock,scripts/**,**/*.ipynb" <br> <br> if [ ! -s ./repomix-output.xml ]; then <br>     echo "‚ùå ERROR: Repomix failed to generate the codebase context. Aborting." <br>     exit 1 <br> fi <br> echo "‚úÖ Codebase context aggregated into repomix-output.xml." <br> ``` |
| 1.B | **Build Gemini Prompt** | `[ ]` | **Why:** To create a structured, verifiable prompt that delegates the entire implementation task to Gemini. <br> **How:** Execute the following commands now to create `implementation-prompt.md`. <br> ```bash <br> # Extract the relevant phase from the checklist <br> PHASE_NAME="$ARGUMENTS" <br> awk -v phase="## $PHASE_NAME" 'BEGIN{p=0} $0 ~ phase {p=1; next} /^## / {p=0} p' checklist.md > phase_steps.md <br> <br> # Create the structured prompt for Gemini <br> cat > ./implementation-prompt.md << 'PROMPT' <br> <task> <br> You are an expert programmer. Your task is to implement the code changes described in the provided project checklist for a specific phase. <br> <br> <steps> <br> <1> <br> Review the `<phase_checklist>` to understand the required changes for this phase. <br> </1> <br> <2> <br> Analyze the full `<codebase_context>` to understand the existing code and how to best implement the changes. <br> </2> <br> <3> <br> For each file that needs to be modified, generate the complete, final content of the file. <br> </3> <br> <4> <br> Adhere strictly to the project's existing coding style, conventions, and architectural patterns. <br> </4> <br> <5> <br> Present the final, modified file contents in the structured format specified in `<output_format>`. <br> </5> <br> </steps> <br> <br> <context> <br> <phase_checklist> <br> <!-- Placeholder for the specific phase checklist from phase_steps.md --> <br> </phase_checklist> <br> <br> <codebase_context> <br> <!-- Placeholder for content from repomix-output.xml --> <br> </codebase_context> <br> </context> <br> <br> <output_format> <br> Your entire response must be a series of one or more file blocks. Do not include any conversational text or explanations. Each file block must start with a `---FILE_START---` marker and end with a `---FILE_END---` marker. <br> <br> ---FILE_START--- <br> path/to/your/file1.py <br> ```python <br> # The full, final content of the first modified file <br> print("Hello, World!") <br> ``` <br> ---FILE_END--- <br> <br> ---FILE_START--- <br> path/to/your/file2.js <br> ```javascript <br> // The full, final content of the second modified file <br> console.log("Hello, World!"); <br> ``` <br> ---FILE_END--- <br> <br> ...and so on for every file you modify. <br> </output_format> <br> </task> <br> PROMPT <br> <br> # Inject the phase checklist and repomix context into the prompt <br> sed -i '/<phase_checklist>/r ./phase_steps.md' ./implementation-prompt.md <br> sed -i '/<codebase_context>/r ./repomix-output.xml' ./implementation-prompt.md <br> rm ./phase_steps.md <br> <br> echo "‚úÖ Gemini implementation prompt created at implementation-prompt.md" <br> ``` |
| 1.C | **Execute Gemini Implementation** | `[ ]` | **Why:** To run the implementation and generate the modified file contents. <br> **How:** Execute the `gemini` command now. <br> ```bash <br> # Execute Gemini with the fully-formed prompt file <br> gemini -p "@./implementation-prompt.md" > gemini_output.txt <br> ``` |
| 1.D | **Apply File Changes** | `[ ]` | **Why:** To take Gemini's output and write it to the actual files on the filesystem. <br> **How:** You must now parse `gemini_output.txt` and apply the changes. <br> ```bash <br> #!/bin/bash <br> <br> # This script parses the output from Gemini and applies the file changes. <br> <br> # Check if the output file exists <br> if [ ! -f "gemini_output.txt" ]; then <br>     echo "Error: gemini_output.txt not found." <br>     exit 1 <br> fi <br> <br> # Use awk to process the file <br> awk ' <br> /^---FILE_START---/ { <br>     if (filename) { <br>         # If we were already processing a file, something is wrong with the format <br>         print "Error: Found new FILE_START before FILE_END for file: " filename > "/dev/stderr" <br>         exit 1 <br>     } <br>     getline <br>     filename = $0 <br>     # Skip the code block start line (e.g., ```python) <br>     getline <br>     content = "" <br>     next <br> } <br> /^---FILE_END---/ { <br>     if (!filename) { <br>         print "Error: Found FILE_END without a preceding FILE_START." > "/dev/stderr" <br>         exit 1 <br>     } <br>     # Remove the trailing code block end line (e.g., ```) <br>     sub(/\`\`\`$/, "", content) <br> <br>     # Create directories if they don't exist <br> "mkdir -p $(dirname " filename ")" | /bin/bash <br> <br>     # Write the content to the file <br> print content > filename <br>     print "Updated file: " filename <br> <br>     # Reset for the next block <br>     filename = "" <br>     content = "" <br>     next <br> } <br> { <br>     if (filename) { <br>         if (content) { <br>             content = content "\n" $0 <br>         } else { <br>             content = $0 <br>         } <br>     } <br> } <br> ' gemini_output.txt <br> <br> echo "‚úÖ File updates complete." <br> ``` |
</file>

<file path=".claude/commands/complete-phase.md">
# Command: /complete-phase

**Goal:** Autonomously complete a specific phase of a software engineering project by implementing the required code changes as defined in a checklist.

**Usage:**
`/complete-phase "Phase 2: Core Logic Implementation"`

---

## üî¥ **CRITICAL: MANDATORY EXECUTION FLOW**

**YOUR ROLE IS AN AUTONOMOUS ORCHESTRATOR AND FILE MANAGER. YOU DO NOT PERFORM THE IMPLEMENTATION.**
1.  You MUST identify the target phase from the command arguments.
2.  You MUST read the project's `checklist.md` to find the specific steps for that phase.
3.  You MUST iterate through each step in the phase.
4.  For each step, you MUST identify the file(s) to be modified.
5.  You MUST delegate the modification of EACH file to a separate, specialized sub-agent (`claude edit`).
6.  You MUST provide the sub-agent with the file content and the specific instructions from the checklist step.
7.  You MUST verify that the sub-agent successfully modified the file before proceeding to the next step.

**DO NOT:**
-   ‚ùå Write or modify any code yourself. All implementation is delegated.
-   ‚ùå Try to modify multiple files in a single step. Delegate one file at a time.
-   ‚ùå Proceed to the next step if a file modification fails.

---

## ü§ñ **YOUR EXECUTION WORKFLOW**

| ID | Task Description | State | How/Why & API Guidance |
| :-- | :--- | :--- | :--- |
| 1.A | **Identify and Isolate Phase Steps** | `[ ]` | **Why:** To get the precise instructions for the requested project phase. <br> **How:** Execute a script to parse `checklist.md` and extract only the steps corresponding to the phase name provided in the command arguments. <br> ```bash <br> # Assume the phase name is in a variable, e.g., PHASE_NAME="Phase 2: Core Logic Implementation" <br> # This awk script will print the content between the specified phase header and the next header <br> awk -v phase="## $PHASE_NAME" 'BEGIN{p=0} $0 ~ phase {p=1; next} /^## / {p=0} p' checklist.md > phase_steps.md <br> ``` |
| 1.B | **Loop Through Each Step** | `[ ]` | **Why:** To process each task in the phase sequentially. <br> **How:** Read the `phase_steps.md` file line by line or parse it to handle one step at a time. For each step: |
| 1.C | &nbsp;&nbsp;&nbsp;&nbsp;**Extract File Path(s) and Notes** | `[ ]` | **Why:** To determine the target file and the specific instructions for the sub-agent. <br> **How:** For the current step, parse the text to identify the file path(s) listed under `File(s):` and the instructions under `Notes:`. |
| 1.D | &nbsp;&nbsp;&nbsp;&nbsp;**Delegate to `claude edit` Sub-Agent** | `[ ]` | **Why:** To have a specialized agent perform the actual code modification, ensuring focus and quality. <br> **How:** For each file identified in the previous step, invoke the `claude edit` command. <br> ```bash <br> # Example for a single file modification <br> FILE_PATH="path/to/file.py" <br> INSTRUCTIONS="Refactor the function 'foo' to improve performance by using a cache." <br> <br> # The 'edit' command applies the change directly to the file <br> claude edit "$FILE_PATH" --prompt "$INSTRUCTIONS" <br> <br> # After execution, you MUST verify the file was actually changed. <br> # For example, by checking its modification time or content hash. <br> ``` |
| 1.E | **Mark Phase as Complete** | `[ ]` | **Why:** To update the project status after all steps in the phase are successfully completed. <br> **How:** After the loop finishes, you can update the main `checklist.md` to mark the entire phase as complete. <br> ```bash <br> # This is a conceptual example. The exact command will depend on your script. <br> # It finds the line with the phase name and replaces the space with an 'x' in the checkbox. <br> sed -i "s/\[ \]/\[x\]/g" checklist.md # This is a placeholder, be more specific in a real script <br> ``` |
</file>

<file path=".claude/commands/customplan-gemini-full.md">
# Command: /customplan-gemini-full

**Goal:** Generate a detailed, step-by-step checklist for completing a complex software engineering task, using a custom plan structure provided by the user.

**Usage:**
`/customplan-gemini-full "Refactor the auth system" @./plans/my-custom-plan-template.md`

---

## üî¥ **CRITICAL: MANDATORY EXECUTION FLOW**

**YOUR ROLE IS AN AUTONOMOUS ORCHESTRATOR AND FILE MANAGER. YOU DO NOT PERFORM THE ANALYSIS.**
1.  You MUST gather the user's high-level objective and the path to their custom plan template from the command arguments.
2.  You MUST run `repomix` to create a complete, fresh snapshot of the codebase context.
3.  You MUST build a structured prompt file (`customplan-prompt.md`) that includes the user's objective, the custom plan template, and the codebase context.
4.  You MUST execute `gemini -p "@customplan-prompt.md"`.
5.  You MUST output Gemini's response directly to the user as a Markdown file.

**DO NOT:**
-   ‚ùå Run `find`, `grep`, or any other manual analysis tool. Gemini is responsible for all planning.
-   ‚ùå Create the plan yourself. Your job is to run the process and manage the state.
-   ‚ùå Deviate from the user's provided plan structure.

---

## ü§ñ **YOUR EXECUTION WORKFLOW**

| ID | Task Description | State | How/Why & API Guidance |
| :-- | :--- | :--- | :--- |
| 1.A | **Aggregate Codebase Context** | `[ ]` | **Why:** To provide Gemini with a complete and fresh snapshot of the project for accurate planning. <br> **How:** Execute the following command now. <br> ```bash <br> # The user's high-level objective is in $ARGUMENTS <br> npx repomix@latest . \ <br>   --include "ptycho/**/*.py,**/*.md" \ <br>   --ignore "build/**,node_modules/**,dist/**,*.lock,scripts/**,**/*.ipynb" <br> <br> if [ ! -s ./repomix-output.xml ]; then <br>     echo "‚ùå ERROR: Repomix failed to generate the codebase context. Aborting." <br>     exit 1 <br> fi <br> echo "‚úÖ Codebase context aggregated into repomix-output.xml." <br> ``` |
| 1.B | **Build Gemini Prompt** | `[ ]` | **Why:** To create a structured, verifiable prompt that delegates the entire planning task to Gemini, ensuring it adheres to the user's custom template. <br> **How:** Execute the following commands now to create `customplan-prompt.md`. <br> ```bash <br> # ARG1 is the user request, ARG2 is the path to the custom plan template <br> USER_REQUEST="$1" <br> CUSTOM_PLAN_TEMPLATE_PATH="$2" <br> <br> # Create the structured prompt for Gemini <br> cat > ./customplan-prompt.md << 'PROMPT' <br> <task> <br> You are an expert Staff Engineer. Your task is to create a detailed, step-by-step plan for a software engineering task, based on the user's request, the provided codebase, and a custom plan template. <br> <br> <steps> <br> <1> <br> Analyze the `<user_request>` to understand the high-level goal. <br> </1> <br> <2> <br> Thoroughly analyze the `<codebase_context>` to identify all affected files, modules, and potential side effects. <br> </2> <br> <3> <br> Carefully study the structure and instructions within the `<custom_plan_template>`. <br> </3> <br> <4> <br> Fill out the template by breaking down the task into logical steps that fit the template's structure. For each step, provide clear descriptions, identify relevant files, and summarize the required changes. <br> </4> <br> <5> <br> Generate the final output as a single Markdown file, strictly adhering to the format and placeholders defined in the `<custom_plan_template>`. <br> </5> <br> </steps> <br> <br> <context> <br> <user_request> <br> [Placeholder for the user's request] <br> </user_request> <br> <br> <custom_plan_template> <br> <!-- Placeholder for the user's custom plan template --> <br> </custom_plan_template> <br> <br> <codebase_context> <br> <!-- Placeholder for content from repomix-output.xml --> <br> </codebase_context> <br> </context> <br> <br> <output_format> <br> Your entire response must be the filled-out version of the `<custom_plan_template>`. Do not include any other conversational text, explanations, or formatting outside of what is defined in the template. <br> </output_format> <br> </task> <br> PROMPT <br> <br> # Inject the user request, custom plan template, and repomix context into the prompt <br> echo "$USER_REQUEST" > ./tmp/user_request.tmp <br> sed -i '/<user_request>/r ./tmp/user_request.tmp' ./customplan-prompt.md <br> sed -i '/<custom_plan_template>/r $CUSTOM_PLAN_TEMPLATE_PATH' ./customplan-prompt.md <br> sed -i '/<codebase_context>/r ./repomix-output.xml' ./customplan-prompt.md <br> rm ./tmp/user_request.tmp <br> <br> echo "‚úÖ Gemini custom plan prompt created at customplan-prompt.md" <br> ``` |
| 1.C | **Execute Gemini Planning** | `[ ]` | **Why:** To run the analysis and generate the custom plan. <br> **How:** Execute the `gemini` command now. <br> ```bash <br> # Execute Gemini with the fully-formed prompt file <br> gemini -p "@./customplan-prompt.md" <br> ``` |
</file>

<file path=".claude/commands/customplan.md">
# Command: /customplan

**Goal:** Generate a detailed, step-by-step checklist for completing a complex software engineering task, using a custom plan structure provided by the user.

**Usage:**
`/customplan "Refactor the auth system" @./plans/my-custom-plan-template.md`

---

## üî¥ **CRITICAL: MANDATORY EXECUTION FLOW**

**YOUR ROLE IS AN AUTONOMOUS ORCHESTRATOR AND FILE MANAGER. YOU DO NOT PERFORM THE ANALYSIS.**
1.  You MUST gather the user's high-level objective and the path to their custom plan template from the command arguments.
2.  You MUST read the custom plan template file.
3.  You MUST delegate the task of filling out this plan to a specialized sub-agent (`claude prompt`).
4.  You MUST provide the sub-agent with the user's objective, the content of the custom plan template, and the relevant codebase context.
5.  You MUST output the sub-agent's response directly to the user.

**DO NOT:**
-   ‚ùå Run `find`, `grep`, or any other manual analysis tool. The sub-agent is responsible for all planning.
-   ‚ùå Create the plan yourself. Your job is to run the process and manage the state.
-   ‚ùå Deviate from the user's provided plan structure.

---

## ü§ñ **YOUR EXECUTION WORKFLOW**

| ID | Task Description | State | How/Why & API Guidance |
| :-- | :--- | :--- | :--- |
| 1.A | **Parse Command Arguments** | `[ ]` | **Why:** To get the user's objective and the location of the custom plan template. <br> **How:** From the command arguments, store the user's request (e.g., "Refactor the auth system") and the file path of the template (e.g., `@./plans/my-custom-plan-template.md`). |
| 1.B | **Read Custom Plan Template** | `[ ]` | **Why:** To load the structure that the final plan must adhere to. <br> **How:** Read the full content of the file specified in the command arguments. |
| 1.C | **Delegate to `claude prompt` Sub-Agent** | `[ ]` | **Why:** To have a specialized agent analyze the codebase and fill out the custom plan according to the user's requirements. <br> **How:** Invoke the `claude prompt` command. This command is flexible and allows for a detailed, multi-part prompt. <br> ```bash <br> # Assume USER_REQUEST and PLAN_TEMPLATE_CONTENT are variables holding the respective data. <br> <br> # The prompt is constructed to give the sub-agent clear instructions. <br> claude prompt "You are an expert software architect. Your task is to fill out the following plan template based on the user's request and the provided codebase context. <br> <br> **User Request:** ${USER_REQUEST} <br> <br> **Plan Template to Fill Out:** <br> ${PLAN_TEMPLATE_CONTENT} <br> <br> Please analyze the codebase and provide a detailed, step-by-step plan that fits into the structure of the template. Focus on identifying the correct files, outlining the necessary changes, and estimating potential risks." <br> ``` <br> **Note:** The `claude prompt` command automatically includes the codebase context, so you don't need to manually add it. |
| 1.D | **Output the Result** | `[ ]` | **Why:** To present the final, filled-out plan to the user. <br> **How:** The output from the `claude prompt` command in the previous step is the completed plan. You should print this directly to the console or save it to a file as requested. |
</file>

<file path=".claude/commands/debug-gemini-v2.md">
# Command: /debug-gemini-v2

**Goal:** Autonomously debug and fix a failing test by analyzing the codebase, identifying the root cause, proposing a fix, and applying it.

**Usage:**
`/debug-gemini-v2 "The test `test_user_creation` in `tests/test_users.py` is failing with an AssertionError."`

---

## üî¥ **CRITICAL: MANDATORY EXECUTION FLOW**

**YOUR ROLE IS AN AUTONOMOUS ORCHESTRATOR AND FILE MANAGER. YOU DO NOT PERFORM THE DEBUGGING.**
1.  You MUST gather the user's description of the failing test from the command arguments.
2.  You MUST run `repomix` to create a complete, fresh snapshot of the codebase context.
3.  You MUST build a structured prompt file (`debug-prompt.md`) to delegate the entire debugging process to Gemini.
4.  You MUST execute `gemini -p "@debug-prompt.md"`.
5.  You MUST parse Gemini's response, which will contain the root cause analysis and the modified file contents for the fix.
6.  You MUST present the analysis to the user and apply the file changes.

**DO NOT:**
-   ‚ùå Run `pytest`, `grep`, or any other manual debugging tool. Gemini is responsible for all analysis and fixing.
-   ‚ùå Write or modify any code yourself. Gemini provides the complete, final code.
-   ‚ùå Guess the fix. Gemini's response is the source of truth.

---

## ü§ñ **YOUR EXECUTION WORKFLOW**

| ID | Task Description | State | How/Why & API Guidance |
| :-- | :--- | :--- | :--- |
| 1.A | **Aggregate Codebase Context** | `[ ]` | **Why:** To provide Gemini with a complete and fresh snapshot of the project for accurate debugging. <br> **How:** Execute the following command now. <br> ```bash <br> # The user's high-level objective is in $ARGUMENTS <br> npx repomix@latest . \ <br>   --include "ptycho/**/*.py,**/*.md" \ <br>   --ignore "build/**,node_modules/**,dist/**,*.lock,scripts/**,**/*.ipynb" <br> <br> if [ ! -s ./repomix-output.xml ]; then <br>     echo "‚ùå ERROR: Repomix failed to generate the codebase context. Aborting." <br>     exit 1 <br> fi <br> echo "‚úÖ Codebase context aggregated into repomix-output.xml." <br> ``` |
| 1.B | **Build Gemini Prompt** | `[ ]` | **Why:** To create a structured, verifiable prompt that delegates the entire debugging task to Gemini. <br> **How:** Execute the following commands now to create `debug-prompt.md`. <br> ```bash <br> # Create the structured prompt for Gemini <br> cat > ./debug-prompt.md << 'PROMPT' <br> <task> <br> You are an expert Python developer and debugger. Your task is to analyze a failing test, identify the root cause, and provide a complete, working fix. <br> <br> <steps> <br> <1> <br> Analyze the `<failing_test_description>` to understand the context of the failure. <br> </1> <br> <2> <br> Thoroughly analyze the entire `<codebase_context>`, paying close attention to the failing test file and any related application code it imports or interacts with. <br> </2> <br> <3> <br> Identify the precise root cause of the test failure. This should be a specific bug in the application code, not the test code (unless the test itself is flawed). <br> </3> <br> <4> <br> Formulate a fix. This involves determining which file(s) need to be changed and what the new code should be. <br> </4> <br> <5> <br> Generate a clear, concise explanation of the root cause. <br> </5> <br> <6> <br> Provide the complete, final content of all file(s) that need to be modified to implement the fix. <br> </6> <br> <7> <br> Adhere strictly to the format specified in `<output_format>`. <br> </7> <br> </steps> <br> <br> <context> <br> <failing_test_description> <br> [Placeholder for the user's description of the failing test] <br> </failing_test_description> <br> <br> <codebase_context> <br> <!-- Placeholder for content from repomix-output.xml --> <br> </codebase_context> <br> </context> <br> <br> <output_format> <br> Your entire response must be a single block containing two sections: the analysis and the file modifications. Do not include any conversational text. <br> <br> ---ANALYSIS_START--- <br> [A clear, concise explanation of the root cause of the test failure. Explain the bug, not just the symptom.] <br> ---ANALYSIS_END--- <br> <br> ---MODIFIED_FILES_START--- <br> <br> ---FILE_START--- <br> path/to/your/file_to_fix.py <br> ```python <br> # The full, final content of the fixed file <br> print("This code is now correct.") <br> ``` <br> ---FILE_END--- <br> <br> <!-- Repeat the FILE block for every file you modify --> <br> <br> ---MODIFIED_FILES_END--- <br> </output_format> <br> </task> <br> PROMPT <br> <br> # Inject the user's test description and repomix context into the prompt <br> echo "$ARGUMENTS" > ./tmp/test_desc.tmp <br> sed -i '/<failing_test_description>/r ./tmp/test_desc.tmp' ./debug-prompt.md <br> sed -i '/<codebase_context>/r ./repomix-output.xml' ./debug-prompt.md <br> rm ./tmp/test_desc.tmp <br> <br> echo "‚úÖ Gemini debug prompt created at debug-prompt.md" <br> ``` |
| 1.C | **Execute Gemini Debugging** | `[ ]` | **Why:** To run the analysis and generate the fix. <br> **How:** Execute the `gemini` command now. <br> ```bash <br> # Execute Gemini with the fully-formed prompt file <br> gemini -p "@./debug-prompt.md" > gemini_output.txt <br> ``` |
| 1.D | **Present Analysis and Apply Fix** | `[ ]` | **Why:** To inform the user of the root cause and update the files with Gemini's fix. <br> **How:** You must now parse `gemini_output.txt` to extract the analysis and the file changes, then apply them. <br> ```bash <br> #!/bin/bash <br> <br> # Extract and print the analysis <br> echo "--- Root Cause Analysis ---" <br> awk '/---ANALYSIS_START---/,/---ANALYSIS_END---/' gemini_output.txt | sed '1d;$d' <br> echo "-------------------------" <br> <br> # This script parses the output from Gemini and applies the file changes. <br> # It assumes the file modification blocks are within the ---MODIFIED_FILES_START--- and ---MODIFIED_FILES_END--- markers. <br> <br> # Use awk to process the file modification blocks <br> awk ' <br> BEGIN { in_files_section = 0 } <br> /^---MODIFIED_FILES_START---/ { in_files_section = 1; next } <br> /^---MODIFIED_FILES_END---/   { in_files_section = 0; next } <br> !in_files_section { next } <br> <br> /^---FILE_START---/ { <br>     if (filename) { <br>         print "Error: Found new FILE_START before FILE_END for file: " filename > "/dev/stderr" <br>         exit 1 <br>     } <br>     getline <br>     filename = $0 <br>     getline # Skip code block start <br>     content = "" <br>     next <br> } <br> /^---FILE_END---/ { <br>     if (!filename) { <br>         print "Error: Found FILE_END without a preceding FILE_START." > "/dev/stderr" <br>         exit 1 <br>     } <br>     sub(/\`\`\`$/, "", content) # Remove trailing code block end <br> <br>     "mkdir -p $(dirname " filename ")" | /bin/bash <br>     print content > filename <br>     print "Updated file: " filename <br> <br>     filename = "" <br>     content = "" <br>     next <br> } <br> { <br>     if (filename) { <br>         if (content) { <br>             content = content "\n" $0 <br>         } else { <br>             content = $0 <br>         } <br>     } <br> } <br> ' gemini_output.txt <br> <br> echo "‚úÖ File updates complete." <br> ``` |
</file>

<file path=".claude/commands/debug-gemini-v3.md">
# Command: /debug-gemini-v3

**Goal:** Autonomously debug and fix a failing test by analyzing the codebase, identifying the root cause, proposing a fix, and applying it. This version includes running the test first to get a traceback.

**Usage:**
`/debug-gemini-v3 "pytest tests/test_users.py::test_user_creation"`

---

## üî¥ **CRITICAL: MANDATORY EXECUTION FLOW**

**YOUR ROLE IS AN AUTONOMOUS ORCHESTRATOR AND FILE MANAGER. YOU DO NOT PERFORM THE DEBUGGING.**
1.  You MUST accept a shell command that runs the failing test as an argument.
2.  You MUST execute this command and capture its output (the traceback).
3.  You MUST run `repomix` to create a complete, fresh snapshot of the codebase context.
4.  You MUST build a structured prompt file (`debug-prompt.md`) containing the traceback and codebase context to delegate the debugging process to Gemini.
5.  You MUST execute `gemini -p "@debug-prompt.md"`.
6.  You MUST parse Gemini's response, which will contain the root cause analysis and the modified file contents for the fix.
7.  You MUST present the analysis to the user and apply the file changes.

**DO NOT:**
-   ‚ùå Write or modify any code yourself. Gemini provides the complete, final code.
-   ‚ùå Guess the fix. Gemini's response is the source of truth.

---

## ü§ñ **YOUR EXECUTION WORKFLOW**

| ID | Task Description | State | How/Why & API Guidance |
| :-- | :--- | :--- | :--- |
| 1.A | **Run Failing Test** | `[ ]` | **Why:** To get the exact error message and traceback, which is crucial context for debugging. <br> **How:** Execute the shell command provided by the user and save the output. <br> ```bash <br> # The user's command is in $ARGUMENTS <br> TEST_COMMAND="$ARGUMENTS" <br> echo "Running failing test to capture traceback..." <br> TEST_TRACEBACK=$($TEST_COMMAND 2>&1) <br> if [ $? -eq 0 ]; then <br>     echo "‚úÖ Test passed unexpectedly. Nothing to debug." <br>     exit 0 <br> fi <br> echo "Traceback captured." <br> ``` |
| 1.B | **Aggregate Codebase Context** | `[ ]` | **Why:** To provide Gemini with a complete and fresh snapshot of the project for accurate debugging. <br> **How:** Execute the following command now. <br> ```bash <br> npx repomix@latest . \ <br>   --include "ptycho/**/*.py,**/*.md" \ <br>   --ignore "build/**,node_modules/**,dist/**,*.lock,scripts/**,**/*.ipynb" <br> <br> if [ ! -s ./repomix-output.xml ]; then <br>     echo "‚ùå ERROR: Repomix failed to generate the codebase context. Aborting." <br>     exit 1 <br> fi <br> echo "‚úÖ Codebase context aggregated into repomix-output.xml." <br> ``` |
| 1.C | **Build Gemini Prompt** | `[ ]` | **Why:** To create a structured, verifiable prompt that delegates the entire debugging task to Gemini. <br> **How:** Execute the following commands now to create `debug-prompt.md`. <br> ```bash <br> # Create the structured prompt for Gemini <br> cat > ./debug-prompt.md << 'PROMPT' <br> <task> <br> You are an expert Python developer and debugger. Your task is to analyze a failing test, identify the root cause using the provided traceback, and provide a complete, working fix. <br> <br> <steps> <br> <1> <br> Analyze the `<test_traceback>` to understand the exact point and nature of the failure. <br> </1> <br> <2> <br> Thoroughly analyze the entire `<codebase_context>`, using the traceback to focus on the relevant files and lines of code. <br> </2> <br> <3> <br> Identify the precise root cause of the test failure. This should be a specific bug in the application code, not the test code (unless the test itself is flawed). <br> </3> <br> <4> <br> Formulate a fix. This involves determining which file(s) need to be changed and what the new code should be. <br> </4> <br> <5> <br> Generate a clear, concise explanation of the root cause. <br> </5> <br> <6> <br> Provide the complete, final content of all file(s) that need to be modified to implement the fix. <br> </6> <br> <7> <br> Adhere strictly to the format specified in `<output_format>`. <br> </7> <br> </steps> <br> <br> <context> <br> <test_traceback> <br> [Placeholder for the captured test traceback] <br> </test_traceback> <br> <br> <codebase_context> <br> <!-- Placeholder for content from repomix-output.xml --> <br> </codebase_context> <br> </context> <br> <br> <output_format> <br> Your entire response must be a single block containing two sections: the analysis and the file modifications. Do not include any conversational text. <br> <br> ---ANALYSIS_START--- <br> [A clear, concise explanation of the root cause of the test failure. Explain the bug, not just the symptom.] <br> ---ANALYSIS_END--- <br> <br> ---MODIFIED_FILES_START--- <br> <br> ---FILE_START--- <br> path/to/your/file_to_fix.py <br> ```python <br> # The full, final content of the fixed file <br> print("This code is now correct.") <br> ``` <br> ---FILE_END--- <br> <br> <!-- Repeat the FILE block for every file you modify --> <br> <br> ---MODIFIED_FILES_END--- <br> </output_format> <br> </task> <br> PROMPT <br> <br> # Inject the traceback and repomix context into the prompt <br> echo "$TEST_TRACEBACK" > ./tmp/traceback.tmp <br> sed -i '/<test_traceback>/r ./tmp/traceback.tmp' ./debug-prompt.md <br> sed -i '/<codebase_context>/r ./repomix-output.xml' ./debug-prompt.md <br> rm ./tmp/traceback.tmp <br> <br> echo "‚úÖ Gemini debug prompt created at debug-prompt.md" <br> ``` |
| 1.D | **Execute Gemini Debugging** | `[ ]` | **Why:** To run the analysis and generate the fix. <br> **How:** Execute the `gemini` command now. <br> ```bash <br> # Execute Gemini with the fully-formed prompt file <br> gemini -p "@./debug-prompt.md" > gemini_output.txt <br> ``` |
| 1.E | **Present Analysis and Apply Fix** | `[ ]` | **Why:** To inform the user of the root cause and update the files with Gemini's fix. <br> **How:** You must now parse `gemini_output.txt` to extract the analysis and the file changes, then apply them. <br> ```bash <br> #!/bin/bash <br> <br> # Extract and print the analysis <br> echo "--- Root Cause Analysis ---" <br> awk '/---ANALYSIS_START---/,/---ANALYSIS_END---/' gemini_output.txt | sed '1d;$d' <br> echo "-------------------------" <br> <br> # This script parses the output from Gemini and applies the file changes. <br> # It assumes the file modification blocks are within the ---MODIFIED_FILES_START--- and ---MODIFIED_FILES_END--- markers. <br> <br> # Use awk to process the file modification blocks <br> awk ' <br> BEGIN { in_files_section = 0 } <br> /^---MODIFIED_FILES_START---/ { in_files_section = 1; next } <br> /^---MODIFIED_FILES_END---/   { in_files_section = 0; next } <br> !in_files_section { next } <br> <br> /^---FILE_START---/ { <br>     if (filename) { <br>         print "Error: Found new FILE_START before FILE_END for file: " filename > "/dev/stderr" <br>         exit 1 <br>     } <br>     getline <br>     filename = $0 <br>     getline # Skip code block start <br>     content = "" <br>     next <br> } <br> /^---FILE_END---/ { <br>     if (!filename) { <br>         print "Error: Found FILE_END without a preceding FILE_START." > "/dev/stderr" <br>         exit 1 <br>     } <br>     sub(/\`\`\`$/, "", content) # Remove trailing code block end <br> <br>     "mkdir -p $(dirname " filename ")" | /bin/bash <br>     print content > filename <br>     print "Updated file: " filename <br> <br>     filename = "" <br>     content = "" <br>     next <br> } <br> { <br>     if (filename) { <br>         if (content) { <br>             content = content "\n" $0 <br>         } else { <br>             content = $0 <br>         } <br>     } <br> } <br> ' gemini_output.txt <br> <br> echo "‚úÖ File updates complete." <br> ``` |
</file>

<file path=".claude/commands/debug-gemini.md">
# Command: /debug-gemini

**Goal:** Autonomously debug and fix a failing test by analyzing the codebase, identifying the root cause, proposing a fix, and applying it.

**Usage:**
`/debug-gemini "The test `test_user_creation` in `tests/test_users.py` is failing with an AssertionError."`

---

## üî¥ **CRITICAL: MANDATORY EXECUTION FLOW**

**YOUR ROLE IS AN AUTONOMOUS ORCHESTRATOR AND FILE MANAGER. YOU DO NOT PERFORM THE DEBUGGING.**
1.  You MUST gather the user's description of the failing test from the command arguments.
2.  You MUST delegate the analysis of the root cause to a specialized sub-agent (`claude prompt`).
3.  You MUST provide this sub-agent with the user's description and the full codebase context.
4.  You MUST then take the root cause analysis from the first sub-agent and delegate the implementation of the fix to a *second*, different sub-agent (`claude edit`).
5.  You MUST provide this second sub-agent with the analysis and the specific file to modify.
6.  You MUST verify that the file was successfully modified.

**DO NOT:**
-   ‚ùå Write or modify any code yourself. All work is delegated.
-   ‚ùå Try to perform analysis and implementation in a single step. Use two separate, specialized agents.
-   ‚ùå Guess the fix or the file to modify. This must come from the analysis agent.

---

## ü§ñ **YOUR EXECUTION WORKFLOW**

| ID | Task Description | State | How/Why & API Guidance |
| :-- | :--- | :--- | :--- |
| 1.A | **Delegate Root Cause Analysis** | `[ ]` | **Why:** To use a specialized agent to analyze the entire codebase and pinpoint the exact cause of the bug. <br> **How:** Invoke the `claude prompt` command with a detailed request for analysis. <br> ```bash <br> # Assume the user's description is in a variable, e.g., BUG_DESCRIPTION <br> # The prompt asks the agent to identify the file and the root cause. <br> claude prompt "You are an expert debugger. Analyze the codebase to find the root cause of the following issue: '${BUG_DESCRIPTION}'. Your response MUST identify the single file that needs to be fixed and provide a clear, concise explanation of the bug. Format your response as 'File: path/to/file.py\n\nReason: [Your explanation]'." > analysis_result.txt <br> ``` |
| 1.B | **Extract File Path and Reason** | `[ ]` | **Why:** To get the specific information needed to delegate the fix to the next agent. <br> **How:** Parse the `analysis_result.txt` file to extract the file path and the reason for the failure. <br> ```bash <br> # Extract the file path <br> FILE_TO_FIX=$(grep "File:" analysis_result.txt | cut -d' ' -f2) <br> <br> # Extract the reason <br> REASON_FOR_FIX=$(grep -v "File:" analysis_result.txt | sed 's/Reason: //') <br> <br> # You MUST validate that you got a file path. If not, the analysis failed, and you should stop. <br> if [ -z "$FILE_TO_FIX" ]; then <br>   echo "Error: Analysis agent did not identify a file to fix." <br>   exit 1 <br> fi <br> ``` |
| 1.C | **Delegate Implementation of the Fix** | `[ ]` | **Why:** To use a separate, specialized agent for code modification, ensuring it acts only on the verified analysis. <br> **How:** Invoke the `claude edit` command, providing the file to fix and the analysis as the prompt. <br> ```bash <br> # The 'edit' command applies the change directly to the file. <br> # The prompt is the reason extracted from the previous step. <br> claude edit "$FILE_TO_FIX" --prompt "Please fix the bug in this file. The root cause is: ${REASON_FOR_FIX}" <br> ``` |
| 1.D | **Verify the Fix** | `[ ]` | **Why:** To ensure the sub-agent successfully modified the file. <br> **How:** After the `edit` command completes, you should verify that the file's content has actually changed. This could be done by checking its modification time or by hashing the file before and after the command. <br> ```bash <br> # This is a conceptual example. <br> # A real implementation would be more robust. <br> echo "File ${FILE_TO_FIX} has been modified by the agent." <br> ``` |
| 1.E | **(Optional) Run Tests** | `[ ]` | **Why:** To confirm that the fix actually resolved the issue. <br> **How:** If you know the command to run the tests (e.g., `pytest`), you can run it now to see if the original failure is gone. |
</file>

<file path=".claude/commands/gemdiffs.md">
# Command: /gemdiffs

**Goal:** Generate a diff of the changes that would be made by a Gemini command.

**Usage:**
`/gemdiffs /<command> <args...>`

This will run the specified command, but instead of applying the changes, it will output a diff of the changes that would be made.

**Example:**
`/gemdiffs /debug-gemini-v3 "pytest tests/test_users.py::test_user_creation"`

This will run the debug-gemini-v3 command, but instead of applying the fix, it will output a diff of the fix.
</file>

<file path=".claude/commands/geminictx.md">
# Command: /geminictx

**Goal:** Manage the context for Gemini commands.

**Usage:**
`/geminictx <subcommand>`

**Subcommands:**
- `ls`: List the files in the current context.
- `add <file>`: Add a file to the context.
- `rm <file>`: Remove a file from the context.
- `clear`: Clear the context.
- `set <files...>`: Set the context to the specified files.
- `set-like <command>`: Set the context to the files that would be used by the specified command.
</pre>
<p>
This command is useful for managing the context that is sent to Gemini.
The context is a list of files that are relevant to the current task.
When you run a Gemini command, the context is automatically determined based on the command and its arguments.
However, you can use this command to override the automatic context and provide your own.
</p>
<p>
For example, if you are working on a bug that involves two files, you can set the context to those two files:
<code>/geminictx set file1.py file2.py</code>
</p>
<p>
Then, when you run a Gemini command, only those two files will be sent to Gemini.
This can be useful for focusing Gemini's attention on the relevant files and for reducing the size of the context that is sent to Gemini.
</p>
<p>
You can also use the <code>set-like</code> subcommand to set the context to the files that would be used by a particular command.
For example, if you want to see what files would be used by the <code>/debug-gemini-v3</code> command, you can run:
<code>/geminictx set-like /debug-gemini-v3 "pytest tests/test_users.py::test_user_creation"</code>
</p>
<p>
This will set the context to the files that would be used by that command, without actually running the command.
You can then use the <code>ls</code> subcommand to see what files are in the context.
</p>

