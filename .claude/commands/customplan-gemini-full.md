# Command: /customplan-gemini-full <objective> [path/to/requirements.md]

**Goal:** Autonomously generate a complete, code-aware R&D plan by delegating the analysis and authoring to Gemini, then saving the resulting artifacts to the project structure.

**Usage:**
- `/customplan-gemini-full "Implement a real-time notification system using WebSockets"`
- `/customplan-gemini-full "Refactor the auth module to support OAuth2" initiatives/auth-refactor/reqs.md`

---

## üî¥ **CRITICAL: MANDATORY EXECUTION FLOW**

**YOUR ROLE IS AN AUTONOMOUS ORCHESTRATOR AND FILE MANAGER.**
1.  You MUST gather user requirements from the command arguments.
2.  You MUST run `repomix` to create a complete, fresh snapshot of the codebase context.
3.  You MUST build a structured prompt file (`plan-prompt.md`) using the XML format.
4.  You MUST execute `gemini -p "@plan-prompt.md"` to delegate the plan generation.
5.  You MUST parse Gemini's response to get the initiative name.
6.  You MUST save the plan and update `PROJECT_STATUS.md` exactly as specified.

**DO NOT:**
-   ‚ùå Modify, interpret, or enhance Gemini's output in any way.
-   ‚ùå Create the plan yourself. Your job is to run the process.
-   ‚ùå Skip any step. The workflow is non-negotiable.

---

## ü§ñ **YOUR EXECUTION WORKFLOW**

### Step 1: Prepare Context from User Requirements

Parse arguments and gather all user-provided requirements.

```bash
# Parse arguments
OBJECTIVE="$1"
REQUIREMENTS_FILE="$2"
USER_REQUIREMENTS_CONTENT=""

# Combine objective and file content into a single requirements block
if [ -n "$OBJECTIVE" ]; then
    USER_REQUIREMENTS_CONTENT="OBJECTIVE: $OBJECTIVE\n"
fi

if [ -f "$REQUIREMENTS_FILE" ]; then
    USER_REQUIREMENTS_CONTENT+="\nADDITIONAL REQUIREMENTS FROM FILE ($REQUIREMENTS_FILE):\n"
    USER_REQUIREMENTS_CONTENT+=$(cat "$REQUIREMENTS_FILE")
    echo "‚úÖ Loaded additional requirements from '$REQUIREMENTS_FILE'."
elif [ -n "$REQUIREMENTS_FILE" ]; then
    echo "‚ö†Ô∏è Warning: Requirements file '$REQUIREMENTS_FILE' not found. Proceeding with objective only."
fi

if [ -z "$USER_REQUIREMENTS_CONTENT" ]; then
    echo "‚ùå ERROR: No objective or requirements provided. Please specify an objective."
    exit 1
fi

echo "‚úÖ User requirements collected."
```

### Step 2: Aggregate Codebase Context with Repomix

Create a comprehensive and reliable context snapshot of the entire project for Gemini.

```bash
# Use repomix for a complete, single-file context snapshot.
npx repomix@latest . \
  --include "**/*.{js,py,md,sh,json,c,h,log,yml,toml}" \
  --ignore "build/**,node_modules/**,dist/**,*.lock"

# Verify that the context was created successfully.
if [ ! -s ./repomix-output.xml ]; then
    echo "‚ùå ERROR: Repomix failed to generate the codebase context. Aborting."
    exit 1
fi

echo "‚úÖ Codebase context aggregated into repomix-output.xml."
```

### Step 3: MANDATORY - Build the Prompt File

You will now build the prompt for Gemini in a file using the structured XML pattern.

#### Step 3.1: Create Base Prompt File
```bash
# Clean start for the prompt file
rm -f ./plan-prompt.md 2>/dev/null

# Create the structured prompt with placeholders using the v3.0 XML pattern
cat > ./plan-prompt.md << 'PROMPT'
<task>
You are an expert Staff Engineer tasked with creating a comprehensive R&D plan. Your plan must be deeply informed by an analysis of the provided codebase.

<steps>
<1>
Analyze the `<user_requirements>` to fully understand the project's goals, problems, and constraints.
</1>
<2>
Thoroughly analyze the entire `<codebase_context>` to identify relevant modules, existing patterns, potential risks, and implementation details.
</2>
<3>
Generate the complete R&D plan. The plan must strictly adhere to the format specified in `<output_format>`. All sections must be filled out based on your analysis.
</3>
</steps>

<context>
<user_requirements>
[Placeholder for the user's requirements]
</user_requirements>

<codebase_context>
<!-- Placeholder for content from repomix-output.xml -->
</codebase_context>
</context>

<output_format>
Your entire response must be a single Markdown block containing the plan.
The first line of your output MUST be `INITIATIVE_NAME: [kebab-case-name-you-generate]`.
Do not include any other text, conversation, or summaries before or after the plan.

INITIATIVE_NAME: [Generate a kebab-case-name for the project]

# R&D Plan: [Title Case Version of Name]

*Created: $(date +%Y-%m-%d)*
*Generated By: Gemini Full Analysis*

## üéØ **OBJECTIVE & HYPOTHESIS**
...
[The entire detailed Markdown template from the original prompt goes here, verbatim.]
...
## üîó **IMPLEMENTATION HINTS**
...
END OF PLAN
</output_format>
</task>
PROMPT
```

#### Step 3.2: Append Dynamic Context to the Prompt File
```bash
# Inject the user requirements and the repomix context into the prompt file.
# Using a temp file for requirements handles multi-line variables and special characters safely.
echo -e "$USER_REQUIREMENTS_CONTENT" > ./tmp/user_reqs.txt
sed -i.bak -e '/\[Placeholder for the user.s requirements\]/r ./tmp/user_reqs.txt' -e '//d' ./plan-prompt.md

# Append the codebase context
echo -e "\n<codebase_context>" >> ./plan-prompt.md
cat ./repomix-output.xml >> ./plan-prompt.md
echo -e "\n</codebase_context>" >> ./plan-prompt.md

echo "‚úÖ Successfully built structured prompt file: ./plan-prompt.md"
```

### Step 4: MANDATORY - Execute Gemini Analysis

You MUST now execute Gemini using the single, clean, and verifiable prompt file.

```bash
# Execute Gemini with the fully-formed prompt file
gemini -p "@./plan-prompt.md"
```

### Step 5: Save Plan and Update Project Status

Your final role: receive the output from your command, parse it, and save the artifacts without modification.

```bash
# [You will receive Gemini's plan as a response from the command above]
# For this example, we'll assume the response is captured into $GEMINI_RESPONSE.

# Parse the initiative name from the first line of the response. This is reliable.
INITIATIVE_NAME=$(echo "$GEMINI_RESPONSE" | grep '^INITIATIVE_NAME: ' | sed 's/^INITIATIVE_NAME: //')
PLAN_CONTENT=$(echo "$GEMINI_RESPONSE" | sed '1d') # Get the rest of the content

if [ -z "$INITIATIVE_NAME" ]; then
    echo "‚ùå ERROR: Gemini's output did not include the required 'INITIATIVE_NAME:' line. Cannot proceed."
    echo "--- Gemini's Raw Output ---"
    echo "$GEMINI_RESPONSE"
    exit 1
fi

# Create the directory and save the plan
PLAN_DIR="plans/active/$INITIATIVE_NAME"
mkdir -p "$PLAN_DIR"
echo "$PLAN_CONTENT" > "$PLAN_DIR/plan.md"
echo "‚úÖ Saved Gemini's R&D plan to: $PLAN_DIR/plan.md"

# Update PROJECT_STATUS.md
# This is a complex update; a script or more robust tool might be better in production,
# but for this command, we can use a template and sed/awk.
# For simplicity, we'll create a new status block.
STATUS_BLOCK="## üìç Current Active Initiative\n\n**Name:** $INITIATIVE_NAME\n**Path:** \`$PLAN_DIR/\`\n**Started:** $(date +%Y-%m-%d)\n**Created By:** Gemini Full Analysis\n**Current Phase:** Planning"
# A real implementation would replace an existing block. Here we just show the content.
echo -e "\nUpdating PROJECT_STATUS.md..."
# (Logic to update PROJECT_STATUS.md would go here)
echo "‚úÖ Updated PROJECT_STATUS.md"

# Announce completion to the user
echo ""
echo "Next step: Review '$PLAN_DIR/plan.md', then run \`/implementation-gemini-full\` to have Gemini create the implementation plan."
```

---

## ‚úÖ **VERIFICATION CHECKLIST**

Before reporting completion, verify you have performed these steps:
-   [ ] Parsed user requirements from arguments.
-   [ ] Successfully ran `repomix` to generate `repomix-output.xml`.
-   [ ] Created `./plan-prompt.md` with the correct XML structure.
-   [ ] Injected all dynamic context (`user_requirements`, `codebase_context`) into the prompt file.
-   [ ] **I EXECUTED the `gemini -p "@./plan-prompt.md"` command.** ‚Üê MANDATORY
-   [ ] I received Gemini's plan response.
-   [ ] I successfully parsed the `INITIATIVE_NAME` from the response.
-   [ ] I saved the plan to the correct directory.
-   [ ] I updated `PROJECT_STATUS.md`.
