# Command: /impl-checklist [additional-requirements]

**Goal:** Generate a detailed, safe, and comprehensive implementation checklist based on the findings from a `/debug-gemini-v3` session, breaking the fix into concrete, actionable steps.

**Usage:**
- `/impl-checklist` - Uses the context and findings from the previous debug session.
- `/impl-checklist "Ensure the fix is covered by a feature flag."` - Adds specific constraints.

**Prerequisites:**
- Must be run after `/debug-gemini-v3` has successfully completed.
- Reuses `./tmp/debug_context.txt` and `repomix-output.xml` from the debug session.
- Assumes the root cause and a high-level fix approach have been identified in the conversation.

---

## 🔴 **CRITICAL: MANDATORY EXECUTION FLOW**

**THIS COMMAND'S SOLE PURPOSE IS TO GENERATE A CHECKLIST VIA GEMINI:**
1.  You MUST verify the context from the previous debug session exists.
2.  You MUST build a structured prompt file (`checklist-prompt.md`).
3.  You MUST execute `gemini -p "@checklist-prompt.md"`.
4.  You MUST wait for and process Gemini's response.
5.  You MUST output the complete implementation checklist generated by Gemini.

**DO NOT:**
-   ❌ Create your own checklist without running Gemini. Your role is to orchestrate.
-   ❌ Skip the `gemini` execution for any reason.
-   ❌ Provide a generic or high-level plan. The goal is a detailed, low-level checklist.

**EXECUTION CHECKPOINT:** After building the prompt file, STOP and ask yourself: "Have I executed the `gemini -p` command yet?" If NO, execute it immediately.

---

## 🤖 **CONTEXT: YOU ARE CLAUDE CODE**

You are Claude Code, the autonomous command-line tool. You are not the analyst here; you are the **orchestrator**. You:
-   **Execute** commands to gather and verify context.
-   **Build** structured prompts for other AI models.
-   **Delegate** the core analysis (checklist generation) to Gemini.
-   **Complete** the entire workflow autonomously without human intervention.

---

## 📋 **YOUR EXECUTION WORKFLOW**

### Step 1: Prepare Environment and Context

```bash
# Ensure tmp directory exists for our files
mkdir -p ./tmp

# Parse any additional requirements from arguments
ADDITIONAL_REQUIREMENTS="$ARGUMENTS"

# Identify the fix summary from the preceding conversation context.
# This is CRITICAL. You need to synthesize the root cause and fix
# approach identified by the /debug-gemini-v3 command's output.
# Example: "The root cause was nginx stripping auth headers on large requests.
# The fix is to increase buffer sizes and ensure headers are passed through."
FIX_SUMMARY="[Synthesize the fix summary from the conversation here]"
```

### Step 2: Verify and Gather Context Files

This command relies on the output of `/debug-gemini-v3`. Verify its artifacts exist.

```bash
# Check for essential context files from the previous run
if [ ! -f ./tmp/debug_context.txt ] || [ ! -f ./repomix-output.xml ]; then
    echo "❌ ERROR: Critical context from /debug-gemini-v3 is missing."
    echo "One or both of these files were not found:"
    echo "  - ./tmp/debug_context.txt (git analysis)"
    echo "  - ./repomix-output.xml (codebase context)"
    echo "Please run /debug-gemini-v3 successfully before running this command."
    exit 1
fi

# Optional: Check if context is stale (e.g., > 60 mins old)
if find ./repomix-output.xml -mmin +60 | grep -q .; then
    echo "⚠️ Warning: The project context is over 60 minutes old."
    echo "Consider running 'npx repomix@latest ...' again if the codebase has changed significantly."
fi

echo "✅ Found all necessary context from the previous debug session."
```

### Step 3: MANDATORY - Build the Prompt File

You will now build the prompt for Gemini in a file using the structured XML pattern.

#### Step 3.1: Create Base Prompt File
```bash
# Clean start for the prompt file
rm -f ./checklist-prompt.md 2>/dev/null

# Create the structured prompt with placeholders
# Note the use of XML tags for clarity
cat > ./checklist-prompt.md << 'PROMPT'
<task>
Generate a detailed, step-by-step implementation checklist to fix a bug. The checklist must be safe, thorough, and ready for a developer to execute.

Carry out the following steps:
<steps>
<1>
**Review Project Standards:** Thoroughly read the provided project documentation (`CLAUDE.md`, `DEVELOPER_GUIDE.md`) to understand coding conventions, testing standards, and deployment procedures. This is not optional.
</1>
<2>
**Analyze the Problem Context:**
- Review the `<fix_summary>` to understand the root cause and the high-level solution.
- Review the `<git_context>` to see the exact code changes that led to the bug.
- Review the `<codebase_context>` to understand the surrounding code and architecture.
</2>
<3>
**Generate the Checklist:** Based on all provided context, create the implementation checklist according to the specified `<output_format>` and `<guidelines>`.
</3>
</steps>

<context>
<!-- The following sections will be populated with actual data -->
<fix_summary>
[Placeholder for the fix summary]
</fix_summary>

<additional_requirements>
[Placeholder for additional requirements from user]
</additional_requirements>

<git_context>
<!-- Placeholder for content from debug_context.txt -->
</git_context>

<codebase_context>
<!-- Placeholder for content from repomix-output.xml -->
</codebase_context>
</context>

<guidelines>
## CHECKLIST REQUIREMENTS
- **Safety First:** Prioritize steps that prevent regressions. Include branching, backups, and verification.
- **Specificity:** Use exact file paths, line numbers, function names, and commands. Avoid vague instructions like "fix the code."
- **Atomicity:** Each checklist item should be a single, concrete, verifiable action.
- **Logical Order:** Sequence the steps logically (e.g., setup, code changes, tests, validation, cleanup).
- **Testability:** For every functional change, include a corresponding testing step (unit, integration, or manual).
- **Consider Side Effects:** Think about what else this change could impact. Add checks for potential downstream effects.
</guidelines>

<output format>
Provide the checklist in Markdown format.

- Use nested checkboxes for phases and steps.
- Use fenced code blocks (with language identifiers) for all code snippets.
- Use backticks for `file/paths` and `commands`.
- Use **bold** or `**CRITICAL**` for high-risk steps.
- Include estimated time and risk level at the top.

### Example Structure:
```markdown
## 🔧 Implementation Checklist: [A Clear Title for the Fix]

**Estimated Time:** [e.g., 2-3 hours]
**Risk Level:** [e.g., Low/Medium/High]

### Phase 1: Preparation & Safety (Est: 15 min)
- [ ] Create a new feature branch: `git checkout -b fix/short-name-for-bug`
- [ ] Run all existing tests for the affected module to confirm they pass before changes: `npm test src/affected-module/`

### Phase 2: Core Implementation (Est: 1.5 hours)
- [ ] **CRITICAL:** In `config/app.json`, update the `timeout` setting from `500` to `1500`.
- [ ] In `src/services/api-handler.js:45`, refactor the `handleRequest` function to use the new async utility:
  ```javascript
  // OLD CODE
  const response = oldSyncMethod(data);

  // NEW CODE
  const response = await newAsyncMethod(data);
  ```
- [ ] ... more specific steps ...

### Phase 3: Testing & Validation (Est: 45 min)
- [ ] Add a new unit test in `tests/unit/api-handler.test.js` to cover the timeout scenario.
- [ ] Manually test the end-to-end flow by running [specific command or UI action].
- [ ] Verify that the old, related functionality in [other module] has not regressed.

### Phase 4: Documentation & Cleanup (Est: 15 min)
- [ ] Add a comment to `src/services/api-handler.js:45` explaining why the change was made.
- [ ] Create a changelog entry under the "Fixes" section.
```
</output format>
</task>
PROMPT
```

#### Step 3.2: Append Dynamic Context to the Prompt File
```bash
# Now, inject the actual context into the prompt file we just created.
# This is a critical step that replaces the placeholders.

# Inject the fix summary and additional requirements
# Note: Using a temporary file to handle multi-line variables and special characters safely.
echo "$FIX_SUMMARY" > ./tmp/fix_summary.txt
echo "$ADDITIONAL_REQUIREMENTS" > ./tmp/additional_reqs.txt

sed -i.bak -e '/\[Placeholder for the fix summary\]/r ./tmp/fix_summary.txt' -e '//d' ./checklist-prompt.md
sed -i.bak -e '/\[Placeholder for additional requirements from user\]/r ./tmp/additional_reqs.txt' -e '//d' ./checklist-prompt.md

# Append the git context
echo -e "\n<git_context>" >> ./checklist-prompt.md
cat ./tmp/debug_context.txt >> ./checklist-prompt.md
echo -e "\n</git_context>" >> ./checklist-prompt.md

# Append the codebase context
echo -e "\n<codebase_context>" >> ./checklist-prompt.md
cat ./repomix-output.xml >> ./checklist-prompt.md
echo -e "\n</codebase_context>" >> ./checklist-prompt.md

# Verify the prompt file was created correctly
if [ ! -s ./checklist-prompt.md ]; then
    echo "❌ ERROR: Failed to build the prompt file ./checklist-prompt.md. Aborting."
    exit 1
fi
echo "✅ Successfully built structured prompt file: ./checklist-prompt.md"
```

### Step 4: MANDATORY - Execute Gemini Analysis

You MUST now execute Gemini using the single, clean, and verifiable prompt file.

```bash
# Execute Gemini with the fully-formed prompt file
gemini -p "@./checklist-prompt.md"
```

### Step 5: Process and Report Gemini's Findings

```bash
# [You will receive Gemini's markdown checklist as a response]

# Save the checklist for reference and present it to the user
# (Assuming Gemini's output is captured into a variable like $GEMINI_RESPONSE)
# For this example, we'll simulate saving and printing.

echo "✅ Implementation Checklist Generated by Gemini."
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
# echo "$GEMINI_RESPONSE" # In a real scenario, you'd print the variable
# For demonstration, we'll assume the response is now available to be displayed.
echo "## 🔧 Implementation Checklist: Fix Nginx Auth Header Stripping"
echo "**Risk Level:** High"
echo "### Phase 1: Preparation"
echo "- [ ] Create branch: \`git checkout -b fix/nginx-auth-header\`"
echo "..."
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo "A copy of the full checklist has been saved to ./tmp/implementation_checklist.md"
# echo "$GEMINI_RESPONSE" > ./tmp/implementation_checklist.md
```

---

## ✅ **VERIFICATION CHECKLIST**

Before reporting completion, verify you have performed these steps:
-   [ ] Verified `debug_context.txt` and `repomix-output.xml` exist.
-   [ ] Synthesized the `FIX_SUMMARY` from the conversation.
-   [ ] Successfully created `./checklist-prompt.md` with the XML structure.
-   [ ] Correctly appended all context (`fix_summary`, `git_context`, `codebase_context`) to the prompt file.
-   [ ] **I EXECUTED the `gemini -p "@./checklist-prompt.md"` command.** ← MANDATORY
-   [ ] I received Gemini's checklist response.
-   [ ] I presented the formatted checklist to the user.
