### **Agent Implementation Checklist: Phase 1 - Core Data Structure Refactoring**

**Overall Goal for this Phase:** To refactor the `RawData.generate_grouped_data` method to implement the "group-first" strategy with automated caching, while maintaining full backward compatibility for `gridsize=1`.

**Instructions for Agent:**
1. Copy this checklist into your working memory.
2. Update the `State` for each item as you progress: `[ ]` (Open) -> `[P]` (In Progress) -> `[D]` (Done).
3. Follow the `How/Why & API Guidance` column carefully for implementation details.

---

| ID  | Task Description                                   | State | How/Why & API Guidance |
| :-- | :------------------------------------------------- | :---- | :----------------------------------------------------- |
| **Section 0: Preparation & Context Priming** |
| 0.A | **Review Key Documents & Current Implementation**  | `[D]` | **Why:** To understand the current data loading pipeline and the specific flaws being addressed. <br> **Docs:** `docs/initiatives/smart-subsampling/plan.md` and current `ptycho/raw_data.py` implementation. <br> **Focus:** Study the current `generate_grouped_data` method and `get_neighbor_indices` function. |
| 0.B | **Identify Target Files for Modification**         | `[D]` | **Why:** To have a clear list of files that will be touched during this phase. <br> **Files:** `ptycho/raw_data.py` (Primary modification target). <br> **Note:** No new files created in this phase, only enhancement of existing functionality. |
| **Section 1: Cache Infrastructure Implementation** |
| 1.A | **Implement `_generate_cache_filename` method**    | `[D]` | **Why:** To create a standardized, collision-free naming convention for cache files. <br> **How:** Create a private method that generates filenames like `<dataset_name>.g{gridsize}k{overlap_factor}.groups_cache.npz`. Use the base dataset filename and include gridsize/overlap parameters to ensure uniqueness. <br> **File:** `ptycho/raw_data.py` |
| 1.B | **Implement `_compute_dataset_checksum` method**   | `[D]` | **Why:** To detect when the underlying dataset has changed and cache needs invalidation. <br> **How:** Create a method that computes a hash of key dataset properties (coordinate arrays, data shape). Use `hashlib.md5` on concatenated coordinate arrays. <br> **File:** `ptycho/raw_data.py` |
| 1.C | **Implement `_save_groups_cache` method**          | `[D]` | **Why:** To persist computed groups to disk for future runs. <br> **How:** Use `numpy.savez_compressed` to save the groups array along with metadata (dataset_checksum, gridsize, overlap_factor). Include error handling for write permissions. <br> **File:** `ptycho/raw_data.py` |
| 1.D | **Implement `_load_groups_cache` method**          | `[D]` | **Why:** To load previously computed groups and validate cache integrity. <br> **How:** Use `numpy.load` with error handling. Validate that checksum matches current dataset and parameters match current configuration. Return None if validation fails. <br> **File:** `ptycho/raw_data.py` |
| **Section 2: Group Discovery Enhancement** |
| 2.A | **Implement `_find_all_valid_groups` method**      | `[D]` | **Why:** To exhaustively find all possible neighbor groups across the entire dataset, not just a subset. <br> **How:** Call `get_neighbor_indices` on the complete coordinate arrays, then use `sample_rows` with `n_samples=len(available_indices)` to get all possible groups. Handle edge cases where fewer groups exist than expected. <br> **File:** `ptycho/raw_data.py` |
| 2.B | **Add comprehensive logging for group discovery**  | `[D]` | **Why:** To inform users about the potentially expensive group discovery process. <br> **How:** Add log messages indicating when group discovery starts, how many groups were found, and when caching begins. Use appropriate log levels (INFO for user-facing, DEBUG for detailed progress). <br> **File:** `ptycho/raw_data.py` |
| **Section 3: Core Method Refactoring** |
| 3.A | **Refactor `generate_grouped_data` method logic**  | `[D]` | **Why:** To implement the group-first strategy while maintaining backward compatibility. <br> **How:** Add conditional logic: if `gridsize=1`, use existing sequential logic unchanged. If `gridsize>1`, attempt cache load, fallback to group discovery, then random sample. Keep the existing method signature and return format. <br> **File:** `ptycho/raw_data.py` |
| 3.B | **Implement cache-first group loading strategy**   | `[D]` | **Why:** To avoid recomputing expensive group discovery on subsequent runs. <br> **How:** Try loading cache first. If successful and valid, use cached groups. If cache miss or invalid, fall back to `_find_all_valid_groups` and save new cache. Log which path was taken. <br> **File:** `ptycho/raw_data.py` |
| 3.C | **Implement random group sampling logic**          | `[D]` | **Why:** To select a spatially representative subset from all available groups. <br> **How:** Use `numpy.random.choice` to randomly select `n_samples` groups from the cached/computed group list. Ensure reproducibility with random seed if specified. <br> **File:** `ptycho/raw_data.py` |
| 3.D | **Preserve backward compatibility for gridsize=1** | `[D]` | **Why:** To ensure existing workflows continue to work without any changes. <br> **How:** Add explicit conditional: `if gridsize == 1: return <existing_logic>`. The traditional path should be completely unchanged - no caching, no group discovery, just sequential selection. <br> **File:** `ptycho/raw_data.py` |
| **Section 4: Error Handling & Edge Cases** |
| 4.A | **Handle insufficient groups edge case**           | `[D]` | **Why:** To gracefully handle datasets where fewer groups exist than requested. <br> **How:** After group discovery, check if `len(all_groups) < n_samples`. If so, log a warning and use all available groups instead of failing. Update the actual sample count accordingly. <br> **File:** `ptycho/raw_data.py` |
| 4.B | **Handle cache file I/O errors**                   | `[D]` | **Why:** To provide graceful degradation when cache operations fail (permissions, disk space, etc.). <br> **How:** Wrap cache load/save operations in try-except blocks. Log warnings for cache failures but continue with computation. Never let cache issues prevent data loading. <br> **File:** `ptycho/raw_data.py` |
| 4.C | **Handle corrupted or incompatible cache files**   | `[D]` | **Why:** To detect and recover from cache corruption or format changes. <br> **How:** In `_load_groups_cache`, validate array shapes and data types. If cache data doesn't match expected format, delete the cache file and return None to trigger recomputation. <br> **File:** `ptycho/raw_data.py` |
| **Section 5: Testing & Validation** |
| 5.A | **Test cache creation functionality**              | `[D]` | **Why:** To verify that the cache system works correctly for new datasets. <br> **How:** Create a simple test that loads a dataset with `gridsize>1`, calls `generate_grouped_data`, and verifies that a cache file was created with the correct naming convention. <br> **File:** Add test to existing test suite or create temporary test script. |
| 5.B | **Test cache loading functionality**               | `[D]` | **Why:** To verify that cached groups are correctly loaded on subsequent runs. <br> **How:** Run the same dataset loading twice and verify that the second run loads from cache (check log output and timing). Verify that the same groups are returned. <br> **File:** Add test to existing test suite or create temporary test script. |
| 5.C | **Test backward compatibility for gridsize=1**     | `[D]` | **Why:** To ensure no regressions in existing functionality. <br> **How:** Run data loading with `gridsize=1` and various `n_samples` values. Verify that behavior is identical to the previous implementation (sequential selection, no caching). <br> **File:** Add test to existing test suite or create temporary test script. |
| **Section 6: Finalization** |
| 6.A | **Add docstring updates**                          | `[D]` | **Why:** To document the new caching behavior and group-first strategy. <br> **How:** Update the `generate_grouped_data` method docstring to explain the new caching behavior, group discovery process, and backward compatibility guarantees. Include examples of cache file naming. <br> **File:** `ptycho/raw_data.py` |
| 6.B | **Code formatting & linting**                      | `[D]` | **Why:** To maintain code quality and project standards. <br> **How:** Run the project's standard formatters (e.g., Black) and linters (e.g., Ruff) on `ptycho/raw_data.py`. Fix any style violations or warnings. <br> **File:** `ptycho/raw_data.py` |
| 6.C | **Verify no breaking changes to public API**       | `[D]` | **Why:** To ensure that external code using `RawData` continues to work. <br> **How:** Verify that the `generate_grouped_data` method signature is unchanged and return values have the same format. Check that no existing method parameters were removed or changed. <br> **File:** `ptycho/raw_data.py` |