# TF–Torch Parity (Manual 1000/512) Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Align PyTorch behavior with TensorFlow for `tests/test_integration_manual_1000_512.py` by fixing RawDataTorch coordinate sign parity, probe normalization, object_big defaults, and reassembly crop/mask parity, eliminating the 64×64-only reconstruction artifact.

**Architecture:** Use TF as ground truth for parity. Add small, fast parity tests that compare TF and Torch outputs for synthetic inputs and known offsets. Fix the RawDataTorch sign at container creation (memmap stays unchanged), then address probe normalization and reassembly crop/mask differences, and validate via the long integration test.

**Tech Stack:** Python, pytest, TensorFlow, PyTorch, NumPy

---

## Task 1: RawDataTorch coords_relative sign parity at container creation (RED → GREEN)

**Files:**
- Create: `tests/torch/test_rawdata_coords_relative_sign.py`
- Modify: `ptycho_torch/data_container_bridge.py`

**Step 1: Write the failing test**

```python
# tests/torch/test_rawdata_coords_relative_sign.py
import numpy as np

from ptycho_torch.data_container_bridge import PtychoDataContainerTorch


def test_rawdata_container_flips_coords_relative_sign():
    N = 4
    coords_relative = np.array([[[[1.0], [2.0]]]], dtype=np.float32)  # shape (1, 1, 2, 1)
    grouped_data = {
        "X_full": np.zeros((1, N, N, 1), dtype=np.float32),
        "Y": np.zeros((1, N, N, 1), dtype=np.complex64),
        "coords_relative": coords_relative,
        "coords_offsets": np.zeros((1, 1, 2, 1), dtype=np.float64),
        "nn_indices": np.zeros((1, 1), dtype=np.int32),
    }
    probe = np.zeros((N, N), dtype=np.complex64)

    container = PtychoDataContainerTorch(grouped_data, probe)

    assert np.allclose(container.coords_nominal.cpu().numpy(), -coords_relative)
```

**Step 2: Run test to verify it fails**

Run: `pytest tests/torch/test_rawdata_coords_relative_sign.py::test_rawdata_container_flips_coords_relative_sign -vv`
Expected: FAIL (container currently passes coords_relative through unchanged)

**Step 3: Write minimal implementation**

Flip `coords_relative` inside `PtychoDataContainerTorch.__init__` so RawDataTorch-derived grouped data is aligned with TF/memmap net shift. Memmap path does not use this container.

```python
# ptycho_torch/data_container_bridge.py (inside __init__)
coords_relative = -grouped_data['coords_relative']
...
self.coords_nominal = torch.from_numpy(coords_relative).to(torch.float32)
```

**Step 4: Run test to verify it passes**

Run: `pytest tests/torch/test_rawdata_coords_relative_sign.py::test_rawdata_container_flips_coords_relative_sign -vv`
Expected: PASS

**Step 5: Commit**

```bash
git add tests/torch/test_rawdata_coords_relative_sign.py ptycho_torch/data_container_bridge.py
git commit -m "fix: flip RawDataTorch coords_relative sign in container"
```

---

## Task 2: Probe normalization parity + default probe_scale (RED → GREEN)

**Files:**
- Create: `tests/torch/test_probe_normalization_parity.py`
- Modify: `ptycho_torch/helper.py`, `ptycho_torch/dataloader.py`, `ptycho_torch/config_params.py`, `ptycho_torch/config_factory.py`

**Step 1: Write the failing test**

```python
# tests/torch/test_probe_normalization_parity.py
import numpy as np
import tensorflow as tf

from ptycho import probe as tf_probe
from ptycho_torch.helper import normalize_probe_like_tf


def test_probe_normalization_matches_tf():
    N = 16
    probe_guess = (np.random.rand(N, N) + 1j * np.random.rand(N, N)).astype(np.complex64)

    # TF normalization
    tf_norm = tf_probe.set_probe_guess(probe_guess=probe_guess).numpy()[..., 0]

    # Torch normalization
    torch_norm = normalize_probe_like_tf(probe_guess, probe_scale=4.0)

    assert np.allclose(tf_norm, torch_norm, atol=1e-6)
```

**Step 2: Run test to verify it fails**

Run: `pytest tests/torch/test_probe_normalization_parity.py::test_probe_normalization_matches_tf -vv`
Expected: FAIL (normalize_probe_like_tf missing)

**Step 3: Write minimal implementation**

Add a Torch helper that mirrors TF’s `set_probe_guess` normalization logic.

```python
# ptycho_torch/helper.py
import numpy as np
from ptycho import probe as tf_probe

def normalize_probe_like_tf(probe_guess: np.ndarray, probe_scale: float) -> np.ndarray:
    # Use TF’s mask and normalization math
    mask = tf_probe.get_probe_mask(probe_guess.shape[0]).numpy()[..., 0]
    tamped = mask * probe_guess
    norm = probe_scale * np.mean(np.abs(tamped))
    return (probe_guess / norm).astype(np.complex64)
```

Then wire this into `ptycho_torch/dataloader.py` when loading `probeGuess` (before storing in probes) and ensure `DataConfig.probe_scale` defaults to TF’s 4.0 in `ptycho_torch/config_params.py` and `ptycho_torch/config_factory.py`.

**Step 4: Run test to verify it passes**

Run: `pytest tests/torch/test_probe_normalization_parity.py::test_probe_normalization_matches_tf -vv`
Expected: PASS

**Step 5: Commit**

```bash
git add tests/torch/test_probe_normalization_parity.py ptycho_torch/helper.py ptycho_torch/dataloader.py ptycho_torch/config_params.py ptycho_torch/config_factory.py
git commit -m "fix: normalize probe like TF and align probe_scale default"
```

---

## Task 3: object_big default parity + overlap constraint routing (RED → GREEN)

**Files:**
- Create: `tests/torch/test_object_big_default_parity.py`
- Modify: `ptycho_torch/config_params.py`, `ptycho_torch/config_factory.py`

**Step 1: Write the failing test**

```python
# tests/torch/test_object_big_default_parity.py
from ptycho.config.config import ModelConfig as TFModelConfig
from ptycho_torch.config_params import ModelConfig as PTModelConfig


def test_object_big_default_matches_tf():
    assert PTModelConfig().object_big == TFModelConfig().object_big
```

**Step 2: Run test to verify it fails**

Run: `pytest tests/torch/test_object_big_default_parity.py::test_object_big_default_matches_tf -vv`
Expected: FAIL if defaults diverge

**Step 3: Write minimal implementation**

Align Torch defaults with TF in `ptycho_torch/config_params.py` and ensure `ptycho_torch/config_factory.py` uses the same default when constructing PTModelConfig.

**Step 4: Run test to verify it passes**

Run: `pytest tests/torch/test_object_big_default_parity.py::test_object_big_default_matches_tf -vv`
Expected: PASS

**Step 5: Commit**

```bash
git add tests/torch/test_object_big_default_parity.py ptycho_torch/config_params.py ptycho_torch/config_factory.py
git commit -m "fix: align object_big default with TF"
```

---

## Task 4: Reassembly crop/mask parity (M=20) (RED → GREEN)

**Files:**
- Create: `tests/torch/test_reassembly_crop_parity.py`
- Modify: `ptycho_torch/helper.py`

**Step 1: Write the failing test**

```python
# tests/torch/test_reassembly_crop_parity.py
import numpy as np
import tensorflow as tf
import torch

from ptycho.tf_helper import reassemble_position
from ptycho_torch.helper import reassemble_patches_position_real
from ptycho_torch.config_params import DataConfig, ModelConfig


def test_reassembly_crop_matches_tf():
    N = 64
    patch = np.zeros((1, N, N, 1), dtype=np.complex64)
    patch[0, 10:20, 10:20, 0] = 1 + 0j
    offsets = np.zeros((1, 1, 2, 1), dtype=np.float32)

    tf_out = reassemble_position(
        tf.convert_to_tensor(patch),
        tf.convert_to_tensor(offsets),
        M=20,
    ).numpy()

    data_cfg = DataConfig(N=N, grid_size=(1, 1), C=1)
    model_cfg = ModelConfig(C_forward=1, C_model=1, object_big=True)
    torch_out, _, _ = reassemble_patches_position_real(
        torch.from_numpy(patch).permute(0, 3, 1, 2),
        torch.from_numpy(offsets).permute(0, 3, 1, 2),
        data_cfg,
        model_cfg,
    )
    torch_out = torch_out.detach().cpu().numpy()

    assert np.allclose(tf_out.real, torch_out.real, atol=1e-6)
```

**Step 2: Run test to verify it fails**

Run: `pytest tests/torch/test_reassembly_crop_parity.py::test_reassembly_crop_matches_tf -vv`
Expected: FAIL (crop/mask mismatch)

**Step 3: Write minimal implementation**

Update `ptycho_torch/helper.py` reassembly to apply TF’s M=20 crop and mask normalization. Mirror TF’s normalization mask logic rather than the prototype-mask approach.

**Step 4: Run test to verify it passes**

Run: `pytest tests/torch/test_reassembly_crop_parity.py::test_reassembly_crop_matches_tf -vv`
Expected: PASS

**Step 5: Commit**

```bash
git add tests/torch/test_reassembly_crop_parity.py ptycho_torch/helper.py
git commit -m "fix: align Torch reassembly crop/mask with TF"
```

---

## Task 5: Integration verification against manual 1000/512

**Files:**
- Use existing: `tests/test_integration_manual_1000_512.py`

**Step 1: Run Torch integration test**

Run:
```bash
RUN_LONG_INTEGRATION=1 python -m pytest tests/torch/test_integration_manual_1000_512_torch.py::test_train_infer_cycle_1000_train_512_test -vv | tee tmp/it_torch_manual_1000_512/pytest.log
```
Expected: PASS

**Step 2: Compare diagnostics**

Verify Torch vs TF:
- Probe stats (normalized vs raw)
- coords sign
- reassembly bounding box not 64×64

**Step 3: Commit integration evidence (if required by repo policy)**

Only if policy requires storing logs, move to `.artifacts/` or `tmp/` and link from plan/summary.

---

# Notes
- Full `pytest -q` is currently failing in this repo; run only targeted selectors.
- Store any large artifacts under `tmp/` or `.artifacts/` and do not commit.
